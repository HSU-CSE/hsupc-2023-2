# I. TF-IDF

| 시간 제한 | 메모리 제한 |
| --- | --- |
| 1초 | 512MB |

## 문제

**TF-IDF**(Term Frequency - Inverse Document Frequency)는 정보 검색과 텍스트 마이닝에서 이용하는 가중치로, 여러 문서로 이루어진 문서군이 있을 때 어떤 단어가 특정 문서 내에서 얼마나 중요한 것인지를 나타내는 통계적 수치이다. 문서의 핵심어를 추출하거나, 검색 엔진에서 검색 결과의 순위를 결정하거나, 문서들 사이의 비슷한 정도를 구하는 등의 용도로 사용할 수 있다.

문서를 $d$, 단어를 $t$, 문서의 총 개수를 $n$이라고 표현할 때 TF, DF, IDF는 각각 다음과 같이 정의할 수 있다.

- $tf(d,t)$ : 특정 문서 $d$에서의 특정 단어 $t$의 등장 횟수

- $df(t)$ : 특정 단어 $t$가 등장한 문서의 수

- $idf(t)$ : $log(\frac{n}{1+df(t)})$

**TF-IDF는 TF와 IDF를 곱한 값이다.**

문서의 번호가 주어졌을 때, **해당 문서를 기준**으로 **TF-IDF 값이 높은 순서대로 단어를 정렬**하는 프로그램을 만들어 보자.

## 입력

첫째 줄에 문서의 개수 $N (1 \leq N \leq 100)$과  질의의 개수 $M (1 \leq M \leq 1000)$이 주어지고, 다음 $N$개의 줄에 문서가 한 줄씩 주어진다.

이후 M개의 줄에 **TF-IDF**의 기준이 되는 문서의 번호 $d$가 주어진다. 문서의 번호는 1부터 시작한다.

모든 문서는 알파벳 소문자로 구성되어 있으며, 각각의 단어는 공백으로 구분된다.
한 문서 내의 단어의 개수는 100개 이하이다.

## 출력

$M$개의 줄에 걸쳐 문서의 번호 $d$가 주어졌을 때, 해당 문서에서 등장한 단어들을 **TF-IDF**값이 높은 순서대로 정렬하여 출력한다.

TF-IDF 값이 같다면 알파벳 사전순으로 정렬하라. 중복 등장한 단어는 한 번만 출력하고, 단어는 공백으로 구분한다.

## 예제 입력

```
3 2
apple is delicious
banana is delicious
good is good
1
3
```

## 예제 출력

```
apple delicious is
good is
```

## 예제 설명

**TF** : 특정 문서 $d$에서의 특정 단어 $t$의 등장 횟수

|  | apple | is | delicious | banana | good |
| --- | --- | --- | --- | --- | --- |
| 1 | 1 | 1 | 1 | 0 | 0 |
| 2 | 0 | 1 | 1 | 1 | 0 |
| 3 | 0 | 1 | 0 | 0 | 2 |

**DF** : 특정 단어 $t$가 등장한 문서의 수

| apple | is | delicious | banana | good |
| --- | --- | --- | --- | --- |
| 1 | 3 | 2 | 1 | 1 |

**IDF** : $log(\frac{n}{1+df(t)})$

| apple | is | delicious | banana | good |
| --- | --- | --- | --- | --- |
| 0.1761 | -0.1249 | 0 | 0.1761 | 0.1761 |

**TF-IDF** : TF와 IDF를 곱한 값

|  | apple | is | delicious | banana | good |
| --- | --- | --- | --- | --- | --- |
| 1 | 0.1761 | -0.1249 | 0 | 0 | 0 |
| 2 | 0 | -0.1249 | 0 | 0.1761 | 0 |
| 3 | 0 | -0.1249 | 0 | 0 | 0.3522 |
